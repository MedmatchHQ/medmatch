{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#api-structure","title":"API Structure","text":"<p>This is a quick overview of how the entire API functions. For more in depth info on each topic, further explore the docs site.</p>"},{"location":"#layers","title":"Layers","text":"<p>The API is built on a multi-layer architecture. An overview of each layer and its function:</p> <ul> <li>Data Layer - Defines models that represent how data is structured in the database, and provides methods for simple database actions.</li> <li>Service Layer - Interfaces with the database and returns data in a defined structure. If any data related errors (such as 404s and 409s) occur, this is where they are handled.</li> <li>Controller Layer - Handles core HTTP logic for the route, including extracting data from the request, performing the action requested via the injected service, and returning a response.</li> <li>Router Layer - Configures relevant services and controllers, defines the paths for each endpoint, and applies input validation and other middleware.</li> </ul> <p>There are two other structures that contribute to the request flow of the API.</p>"},{"location":"#input-validation","title":"Input Validation","text":"<p>All input validation is done through middleware, effectively creating a barrier to entry for the API layers. If any input validation errors are encountered through the process, they are automatically converted to an HTTP response and sent back to the client before the request reaches the controller.  </p>"},{"location":"#error-handling","title":"Error Handling","text":"<p>If any errors occur within the controller logic, such as an absent document or an id conflict, a custom error is thrown, passed to the error handler, converted to an HTTP response, and sent to the client. This allows the controller to delegate most of the error logic to the error handler, with the HTTP configuration defined within the custom error class. This also keeps any HTTP logic out of the service layer, maintaining the desired amount of decoupling.</p>"},{"location":"#overview","title":"Overview","text":"<p>Below is a diagram that details the flow of a request through the api  </p> <p></p>"},{"location":"#file-structure","title":"File Structure","text":"<p>The backend follows a modular structure, keeping all structures related to a certain feature nearby, within one directory. Each module follows a similar structure.</p> <ul> <li>*.model.ts - The data layer for the module. Contains relavent interfaces and <code>mongoose</code> models for the given feature.</li> <li>*.service.ts - The service layer for the module. Defines a service class and methods for the given feature.</li> <li>*.controller.ts - The controller layer for the module. Defines a controller class and request handlers for the given feature.</li> <li>*.router.ts - The router layer for the module. Configures the services, controllers, and routes for the given feature.</li> <li>utils<ul> <li>*.errors.ts - Defines custom errors thrown in the service, configured to be converted to an HTTP response.</li> <li>*.validator.ts - Contains input validation logic and models for the given feature.</li> </ul> </li> </ul>"},{"location":"controller_layer/","title":"The Controller Layer","text":"<p>The Controller Layer is the entry point for all incoming HTTP requests in Medmatch. Its primary role is to manage HTTP concerns and delegate business logic to the appropriate service. Controllers are intentionally designed to be thin, focusing on request handling rather than complex data manipulation.</p>"},{"location":"controller_layer/#overview","title":"Overview","text":"<p>Controllers handle all aspects related to the HTTP request and response cycle. This includes:</p> <ul> <li>Extracting Request Data: Pulling parameters from the request, such as path parameters (<code>req.params</code>), query parameters (<code>req.query</code>), and request body (<code>req.body</code>).</li> <li>Managing Cookies and Files: Handling operations related to HTTP cookies and incoming file uploads.</li> <li>Configuring Responses: Setting HTTP status codes, headers, and formatting the final JSON response object.</li> </ul> <p>Crucially, controllers should not contain business logic or directly interact with the database (i.e., they should not have direct access to Mongoose models). Instead, all business logic is performed by calling functions from injected service dependencies.</p>"},{"location":"controller_layer/#dependency-injection","title":"Dependency Injection","text":"<p>To facilitate the delegation of business logic, controllers receive the services they depend on as constructor parameters. This practice, known as dependency injection, makes controllers highly testable and promotes modularity by clearly defining their external requirements.</p>"},{"location":"controller_layer/#controller-method-decorator","title":"Controller Method Decorator","text":"<p>Every controller method must be adorned with the <code>@ControllerMethod</code> decorator. This decorator is crucial for two main reasons:</p> <ol> <li>Error Handling Integration: It automatically catches any errors thrown by the controller method (or by the service functions it calls) and forwards them to the global error handler. This offloads error-to-HTTP-response conversion from the controller, keeping its code clean and focused on request processing.</li> <li><code>this</code> Binding: The decorator handles the binding of <code>this</code> context to the class instance for the method call. If you ever get an error similar to <code>Cannot read properties of undefined (reading this)</code>, chances are you forget the <code>ControllerMethod</code> decorator.</li> </ol> The <code>@ControllerMethod</code> Decorator <p>The <code>@ControllerMethod</code> decorator routes any thrown errors to the error handler. You can think of it as equivalently doing the following:</p> <pre><code>try {\n    /* function implementation */\n} catch (err) {\n    next(err);\n}\n</code></pre> User Controller Example user.controller.ts<pre><code>class UserController {\n    constructor(private userService: UserService) {}\n\n    @ControllerMethod()\n    async getUserById(req: Request, res: Response): Promise&lt;void&gt; {\n        const { id } = req.params;\n        const user = await this.userService.getUserById(id);\n        res.status(200).json({\n            status: \"success\",\n            data: user,\n            message: `User with id ${user.id} retrieved successfully`,\n        });\n    }\n\n    /* ...more methods... */\n}\n</code></pre>"},{"location":"controller_layer/#documentation","title":"Documentation","text":"<p>Every controller method must be thoroughly documented using JSDoc. This documentation is crucial for understanding the API's behavior from the client's perspective and for future development. It should include:</p> <ul> <li>A clear and concise description of the function/route's purpose.</li> <li>A list of all parameters, including path parameters, query parameters, and request body parameters, along with their types and descriptions.</li> <li>A list of all possible HTTP status codes the endpoint can return on success or failure.</li> <li>A list of all custom errors that can be thrown either directly by the controller or by the service functions it calls, along with the conditions under which they are thrown.</li> <li>The return type for a successful response, specifically describing the structure of the data field.</li> </ul> Proper Documentation Example user.controller.ts<pre><code>/**\n* Gets a single user by the provided id\n* @param {string} req.params.id User id\n* @returns A user with the corresponding id\n* @codes 200, 404\n* @throws A {@link UserNotFoundError} if a user with the corresponding id does not exist\n*/\n@ControllerMethod()\n    async getUserById(req: Request, res: Response): Promise&lt;void&gt; {\n        const { id } = req.params;\n        const user = await this.userService.getUserById(id);\n        res.status(200).json({\n            status: \"success\",\n            data: user,\n            message: `User with id ${user.id} retrieved successfully`,\n        });\n    }\n</code></pre>"},{"location":"data_layer/","title":"The Data Layer","text":"<p>The Data Layer, also referred to as the persistence layer, is where we define how our application interacts with the MongoDB database using Mongoose. This layer is primarily concerned with data modeling and providing basic database interaction methods.</p>"},{"location":"data_layer/#overview","title":"Overview","text":"<p>Each feature module in Medmatch will have a file ending with <code>.model.ts</code>. These files are dedicated to defining the schema, Mongoose model, and all associated TypeScript types necessary for representing data entities within the database.</p> <p>Visit the Mongoose Docs for more in depth info about interactions with the database.</p> Examples in this doc <p>Most of the example code in this doc represents a users module, but it is not the same as the users module in the repo. The code included here is just to aid with how the general structure should look.</p>"},{"location":"data_layer/#schema-definition","title":"Schema Definition","text":"<p>The Schema is the blueprint for our data. It defines the shape of the documents we store in MongoDB, specifying the fields, their types, validation rules (like <code>required</code>), default values, and other Mongoose-specific options.</p> User Schema Example user.model.ts<pre><code>const userSchema = new Schema({\n    first: { type: String, required: true },\n    last: { type: String, required: true },\n    email: { type: String, required: true, unique: true },\n    password: { type: String, required: true },\n    entryDate: { type: Date, default: () =&gt; Date.now() },\n});\n\ntype UserSchema = InferSchemaType&lt;typeof userSchema&gt;;\n</code></pre>"},{"location":"data_layer/#mongoose-model","title":"Mongoose Model","text":"<p>The Mongoose Model is created based on the defined schema and serves as our direct interface for database operations. It provides methods (like <code>find</code>, <code>findById</code>, <code>create</code>, <code>updateOne</code>, <code>deleteOne</code>, etc.) that allow us to perform CRUD (Create, Read, Update, Delete) operations on the MongoDB collection.</p> User Model Creation user.model.ts<pre><code>const UserModel = mongoose.model&lt;UserSchema&gt;(\"User\", userSchema, \"users\");\n</code></pre>"},{"location":"data_layer/#data-representations-documents-vs-data-transfer-objects-dtos","title":"Data Representations: Documents vs. Data Transfer Objects (DTOs)","text":"<p>Within our codebase, we handle two primary representations of data for each entity:</p> <ol> <li>Document (e.g., <code>UserDoc</code>): This is the raw data shape returned directly from a MongoDB query by Mongoose. A document includes all database fields (like <code>_id</code>, <code>__v</code>), as well as any Mongoose-specific methods (e.g., <code>save()</code>, <code>populate()</code>). We do not return documents directly from our API. This is because documents might contain sensitive fields, or their structure might not be optimal for API responses.</li> <li>Data Transfer Object (DTO e.g., <code>User</code>): This is the simplified, clean data structure that our API actually returns to clients. A DTO only contains the fields explicitly intended for the client, excluding internal database fields or Mongoose methods. DTOs are defined as TypeScript classes.</li> </ol> <p>A Mongoose Document should always be converted to a DTO before a response is sent. Each DTO class should have a <code>static</code> method (commonly named <code>fromDocument</code>) responsible for this conversion.</p> User DTO Example user.model.ts<pre><code>interface UserDoc extends HydratedDocument&lt;UserSchema&gt; {}\n\nclass User implements UserSchema {\n    constructor(\n        public id: string,\n        public first: string,\n        public last: string,\n        public email: string,\n        public password: string,\n        public entryDate: Date\n    ) {}\n\n    static fromDoc(doc: UserDoc): User {\n        return new User(\n            doc._id.toString(),\n            doc.first,\n            doc.last,\n            doc.email,\n            doc.password,\n            doc.entryDate\n        );\n    }\n}\n</code></pre>"},{"location":"data_layer/#additional-types","title":"Additional Types","text":"<p>Beyond the core Document and DTO types, you'll often find other types defined in <code>.model.ts</code> files to facilitate specific operations:</p> <ul> <li> <p>Input Types: Separate types (e.g. <code>InputUser</code>) are defined for request payloads, particularly for creation and update operations. These types exclude fields that shouldn't be provided by the client (e.g., <code>_id</code>, timestamps, or certain sensitive fields).</p> Input User DTO user.model.ts<pre><code>interface InputUser {\n    first: string;\n    last: string;\n    email: string;\n    password: string;\n    entryDate: Date;\n}\n</code></pre> <p>Or, in this case, equivalently: user.model.ts<pre><code>type InputUser = UserSchema\n</code></pre></p> <p>Types for PATCH methods will typically be similar to <code>Partial&lt;InputUser&gt;</code></p> </li> <li> <p>Populated Documents: Mongoose allows for referencing documents in other collections (population). DTOs will almost always represent populated data. However, for internal consistency and to allow for flexible data retrieval, we also define types for both unpopulated and fully populated documents.</p> <p>When querying the database, the returned Mongoose Document type (<code>UserDoc</code> in the example above) should generally reflect the populated state. This means the default type alias for a Mongoose model will expect populated fields.</p> </li> </ul>"},{"location":"error_handling/","title":"Error Handling","text":""},{"location":"error_handling/#overview","title":"Overview","text":"<p>The main idea behind our error handler is instead of handling errors directly within controller or service functions by constructing HTTP responses, errors are propagated upwards until they reach a designated global error handler. This error handler is responsible for intercepting thrown errors and converting them into appropriate HTTP responses sent back to the client.</p> <p>This design choice offers several benefits:</p> <ul> <li>Decoupling: Keeps HTTP-specific logic out of the service layer, maintaining a clear separation of concerns.</li> <li>Reduced Boilerplate: Minimizes redundant <code>if</code> statements, <code>try...catch</code> blocks, and error response construction across various controllers and services.</li> <li>Improved Readability: Allows controller and service functions to focus primarily on their core business logic.</li> </ul>"},{"location":"error_handling/#custom-error-objects","title":"Custom Error Objects","text":"<p>To enable the error handler to construct precise HTTP responses, we utilize custom <code>HttpError</code> objects that extend TypeScript's built-in <code>Error</code> class (<code>HttpError</code> is a horrible name and it will hopefully be fixed soon). These custom errors are throwable just like standard errors but include additional parameters important for generating a meaningful API response.</p> <p><code>HttpError</code>'s important properties are:</p> <ul> <li><code>status</code>: An HTTP status code (e.g., <code>404</code>, <code>409</code>, <code>200</code>).</li> <li><code>details</code>: A human-readable message describing the error.</li> <li><code>code</code>: A unique identifier for the specific error type from the <code>ErrorCode</code> enum (e.g., <code>USER_NOT_FOUND</code>, <code>CONFLICT</code>).</li> </ul> The <code>ErrorCode</code> enum <p>The <code>ErrorCode</code> enum contains all error codes that can come out of the API, including general error codes like a generic <code>INTERNAL_SERVER_ERROR</code> (represented by the <code>GeneralCode</code> sub-enum ), and more specialized codes such as <code>USER_NOT_FOUND</code> (from the <code>UserCode</code> sub-enum). </p> <code>NotFoundError</code> Example errors.ts<pre><code>class NotFoundError extends HttpError {\n  constructor(\n    public details: string,\n    public code: ErrorCode = GeneralCode.NotFound,\n    public status: number = 404\n  ) {\n    super(details, code, status);\n  }\n}\n</code></pre> Further Specializing Errors <p>Each module will typically further extend specific <code>HttpError</code>s for readability and the DRY principle. For example, the <code>User</code> module creates its own <code>UserNotFoundError</code>:</p> utils/user.errors.ts<pre><code>class UserNotFoundError extends NotFoundError {\n    constructor(message: string = \"User not found\") {\n        super(message, UserCode.UserNotFound);\n    }\n}\n</code></pre>"},{"location":"error_handling/#flow-of-custom-errors","title":"Flow of Custom Errors","text":"<ol> <li>Service Layer: The Service Layer is the primary location for throwing custom errors related to business logic or data integrity. For example, if a service attempts to retrieve a user from the database but the user is not found, it will throw a <code>UserNotFoundError</code>.     user.service.ts<pre><code>async function getUserById(id: string): Promise&lt;User&gt; {\n  const user = await this.userModel.findById(id);\n  if (!user) {\n    throw new UserNotFoundError(`User with ID ${id} not found.`);\n  }\n  return user;\n}\n</code></pre></li> <li> <p>Controller Layer: When a Controller Layer function calls a service function that might throw a custom error, the controller itself will re-throw this error. It does not attempt to handle the error by constructing a response. This allows the error to propagate up the call stack.</p> user.controller.ts<pre><code>export class UserController {\n\n  @ControllerMethod\n  async getUser(req: Request, res: Response, next: NextFunction) {\n    const userId = req.params.id;\n    // Any error thrown by this function is caught and sent to the error \n    // handler\n    const user = await this.userService.getUserById(userId);\n    return user;\n  }\n}\n</code></pre> The <code>@ControllerMethod</code> Decorator <p>The <code>@ContrllerMethod</code> decorator is what routes any thrown errors to the error handler. You can think of it as equivalently doing the following: </p> <pre><code>try {\n    /* function implementation */\n} catch (err) {\n    next(err);\n}\n</code></pre> <p>Truthfully, it has a little more functionality than just routing errors (which is why it's not called <code>@HandleErrors</code>), but that's frankly unimportant for these docs.</p> </li> <li> <p>Global Error Handler: The custom error is eventually caught by a dedicated Express error handling middleware. This middleware inspects the error:</p> <ul> <li>If the error is an instance of <code>HttpError</code>, it extracts the <code>status</code>, <code>details</code>, and <code>code</code> and constructs an appropriate JSON HTTP response.</li> <li>If a non-custom, generic <code>Error</code> (or any other unexpected type) is thrown, the handler defaults to a generic <code>500 Internal Server Error</code> response to prevent sensitive information leakage and ensure a consistent fallback.</li> </ul> Other Errors <p>The error handler will also handle other possible errors thrown by third party middleware, such as <code>MulterError</code>s.</p> </li> </ol>"},{"location":"input_validation/","title":"Input Validation","text":""},{"location":"input_validation/#overview","title":"Overview","text":"<p>Our approach to input validation relies heavily on middleware. This middleware acts as a gatekeeper, processing incoming requests and validating their parameters before they ever reach the controller layer. This allows controllers and services to assume that all incoming data is valid and correctly structured, simplifying their implementation and reducing the need for redundant checks.</p> Importance of Testing <p>Since controllers rely on the integrity of input validation, thorough testing of the middleware is important. If input validation fails to catch invalid data, it can lead to unexpected behavior or even security vulnerabilities within the application.</p>"},{"location":"input_validation/#validation-libraries","title":"Validation Libraries","text":"<p>Medmatch utilizes two primary libraries for input validation:</p> <ol> <li><code>express-validator</code>: Primarily used for validating non-body parameters such as path parameters, query parameters, and miscellaneous body fields that are not ideally handled by class-validator.</li> <li><code>class-validator</code>: Used for robust of request bodies, leveraging TypeScript classes and decorators.</li> </ol>"},{"location":"input_validation/#request-body-validation-with-class-validator","title":"Request Body Validation with <code>class-validator</code>","text":"<p><code>class-validator</code> is great for validating structured data like request bodies, since it matches json to a class object. We will talk more about how to create validators in the <code>utils</code> section.</p> <p>Our backend provides helper functions that abstract away the boilerplate of <code>class-validator</code> integration, making it straightforward to apply body validation. For example, the <code>validateBody</code> function creates a request handler that validates the body based on the provided validator. Below is an example for creating a user: user.router.ts<pre><code>userRouter.post(\n    \"/\",\n    validation(validateBody(UserValidator)),\n    userController.createUser\n);\n</code></pre> Other important helper functions are <code>validatePartialBody</code>, which only validates present body fields against the provided validator (useful for <code>PATCH</code> routes), and <code>validateFile</code>. </p> The <code>validation</code> Function <p>All validation middleware must be wrapped in the <code>validation</code> function. This ensures that all errors are properly aggregated and sent to the error handler if necessary</p> Validator Classes <p>Validator classes are where you define the constraints that you want the incoming objects to fit. Below is an example of a validator you might use on a request body to a POST users endpoint</p> <p>/utils/user.validators.ts<pre><code>class UserValidator {\n    @IsString()\n    @IsNotEmpty()\n    name!: string;\n\n    @IsEmail()\n    @IsNotEmpty()\n    email!: string;\n\n    @IsString()\n    @IsNotEmpty()\n    password!: string;\n\n    @IsNotEmpty()\n    @IsInt()\n    @Min(1)\n    age!: number;\n}\n</code></pre> Note that Typescript will yell at you if you don't use the non-null assertion operator (the exclamation point)</p> <p>Feel free to take a look at the <code>class-validator</code> docs, although some more details will be given in the <code>utils</code> section.</p>"},{"location":"input_validation/#non-body-parameter-validation-with-express-validator","title":"Non-Body Parameter Validation with <code>express-validator</code>","text":"<p>While <code>class-validator</code> is great for body validation, <code>express-validator</code> is better for validating other parts of the request, such as path and query parameters.</p> <p><code>express-validator</code> is particularly useful for common validations like ensuring an ID is a valid MongoDB ObjectId or checking if a parameter is an integer. Helper functions are provided to simplify these common validation scenarios.</p> <code>validateId</code> Helper Function for Path Parameter user.router.ts<pre><code>userRouter.get(\n    \"/:id\",\n    validation(validateId(\"id\")),\n    userController.getUserById\n);\n</code></pre> <p>For any other specific validation needs (e.g., cookies, unique query parameters, or complex path segment patterns), <code>express-validator</code> provides the flexibility to create custom validation chains.</p> <p>Peruse the <code>express-validator</code> docs for information on how to use it.</p>"},{"location":"input_validation/#error-reporting-to-client","title":"Error Reporting to Client","text":"<p>When validation fails, all detected validation issues are collected, converted to <code>IValidationError</code>s and passed to the global error handler as an array. This array is then included in the API response, providing the client with a complete list of problems in a single request.</p> <ul> <li>Combined Errors: Both <code>class-validator</code> and <code>express-validator</code> errors are aggregated.</li> <li>Full Visibility: The client receives all validation errors upfront, eliminating the need for iterative trial-and-error debugging.</li> </ul>"},{"location":"service_layer/","title":"The Service Layer","text":"<p>The Service Layer is the core of our application's business logic. It encapsulates all the operations required to fulfill a request, manage data, and enforce business rules, while knowing nothing about HTTP or how to connect to the database.</p>"},{"location":"service_layer/#overview","title":"Overview","text":"<p>Each module's service layer is defined as a TypeScript class within a file named <code>*.service.ts</code>. These service classes are designed to be highly focused on their specific domain (e.g., <code>UserService</code> for user-related operations).</p> <p>A key principle of the service layer is dependency injection. Service classes receive the Mongoose models they depend on (e.g., <code>UserModel</code> for <code>UserService</code>) as parameters in their constructors. This design promotes testability and modularity, as dependencies can be easily swapped or mocked during testing.</p>"},{"location":"service_layer/#responsibilities-and-principles","title":"Responsibilities and Principles","text":"<p>The service layer adheres to strict principles to maintain a clean and maintainable architecture:</p> <ul> <li>Business Logic Encapsulation: Services are solely responsible for implementing the application's business rules and logic. This includes data manipulation, complex computations, and coordinating operations across multiple data models.</li> <li>HTTP Agnosticism: Service methods should have no knowledge of HTTP whatsoever. They should not directly access <code>req</code> or <code>res</code> objects, set HTTP status codes, or format HTTP responses. This strict separation ensures that the service layer remains reusable across different interfaces (e.g., an API, a command-line tool, or another service).</li> <li>Custom Error Throwing: As detailed in the Error Handling section, services are the primary place where custom <code>HttpError</code> objects are thrown. If a business logic error occurs (e.g., a user is not found, or an email already exists), the service will throw a specific custom error (e.g., <code>UserNotFoundError</code>, <code>ConflictError</code>). This allows the global error handler to translate these logical errors into appropriate HTTP responses.<ul> <li>Module-Specific Errors: For each new module, corresponding custom errors (e.g., <code>PostNotFoundError</code>, <code>CommentUnauthorizedError</code>) should be defined. This makes error identification clear and enables precise client-side handling.</li> </ul> </li> <li>Input and Output: Service methods should take specific parameters as input, rather than a generic <code>Request</code> object. They should always return Data Transfer Objects (DTOs), not raw Mongoose documents. This ensures that the data leaving the service layer is clean, formatted for API consumption, and free of database-specific artifacts.</li> </ul> User Service Example user.service.ts<pre><code>class UserService {\n    constructor(private userModel: Model&lt;UserSchema&gt;) {}\n\n    async getUserById(userId: string): Promise&lt;User&gt; {\n        const doc = await this.userModel\n            .findById&lt;UserDoc&gt;(userId)\n            .populate(\"profile.files\")\n            .exec();\n        if (!doc) {\n            throw new UserNotFoundError(`User with id ${userId} not found`);\n        }\n        return User.fromDoc(doc);\n    }\n\n    /* ...more methods... */\n}\n</code></pre>"},{"location":"service_layer/#documentation","title":"Documentation","text":"<p>Every service method must be thoroughly documented with JSDoc. This documentation should include:</p> <ul> <li>A clear and concise description of what the method does.</li> <li>A list of all parameters, including their types and descriptions.</li> <li>The return type and a description of what is returned.</li> <li>A list of all custom errors that the method is capable of throwing, along with conditions under which they are thrown.</li> </ul> Proper Documentation Example user.service.ts<pre><code>/**\n* Gets a single user by unique id\n* @param userId Mongoose user id\n* @returns The user object with given id if present\n* @throws A {@link UserNotFoundError} if the user with provided id is not found\n*/\nasync getUserById(userId: string): Promise&lt;User&gt; {\n    const doc = await this.userModel\n        .findById&lt;UserDoc&gt;(userId)\n        .populate(\"profile.files\")\n        .exec();\n    if (!doc) {\n        throw new UserNotFoundError(`User with id ${userId} not found`);\n    }\n    return User.fromDoc(doc);\n}\n</code></pre>"}]}